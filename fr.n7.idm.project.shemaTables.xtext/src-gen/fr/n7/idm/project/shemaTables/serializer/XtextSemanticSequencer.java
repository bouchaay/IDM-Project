/*
 * generated by Xtext 2.32.0
 */
package fr.n7.idm.project.shemaTables.serializer;

import com.google.inject.Inject;
import fr.n7.idm.project.shemaTables.services.XtextGrammarAccess;
import fr.n7.idm.project.shemaTables.xtext.Algorithm;
import fr.n7.idm.project.shemaTables.xtext.Catalogue;
import fr.n7.idm.project.shemaTables.xtext.Column;
import fr.n7.idm.project.shemaTables.xtext.Constant;
import fr.n7.idm.project.shemaTables.xtext.Constraint;
import fr.n7.idm.project.shemaTables.xtext.DerivedColumn;
import fr.n7.idm.project.shemaTables.xtext.Input;
import fr.n7.idm.project.shemaTables.xtext.Output;
import fr.n7.idm.project.shemaTables.xtext.ReferencedColumn;
import fr.n7.idm.project.shemaTables.xtext.ShemaTable;
import fr.n7.idm.project.shemaTables.xtext.Tables;
import fr.n7.idm.project.shemaTables.xtext.XtextPackage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class XtextSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private XtextGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == XtextPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XtextPackage.ALGORITHM:
				sequence_Algorithm(context, (Algorithm) semanticObject); 
				return; 
			case XtextPackage.CATALOGUE:
				sequence_Catalogue(context, (Catalogue) semanticObject); 
				return; 
			case XtextPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case XtextPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case XtextPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case XtextPackage.DERIVED_COLUMN:
				sequence_DerivedColumn(context, (DerivedColumn) semanticObject); 
				return; 
			case XtextPackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case XtextPackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case XtextPackage.REFERENCED_COLUMN:
				sequence_ReferencedColumn(context, (ReferencedColumn) semanticObject); 
				return; 
			case XtextPackage.SHEMA_TABLE:
				sequence_ShemaTable(context, (ShemaTable) semanticObject); 
				return; 
			case XtextPackage.TABLES:
				sequence_Tables(context, (Tables) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Algorithm returns Algorithm
	 *
	 * Constraint:
	 *     (name=ID path=STRING output=Output input=Input)
	 * </pre>
	 */
	protected void sequence_Algorithm(ISerializationContext context, Algorithm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.ALGORITHM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.ALGORITHM__NAME));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.ALGORITHM__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.ALGORITHM__PATH));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.ALGORITHM__OUTPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.ALGORITHM__OUTPUT));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.ALGORITHM__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.ALGORITHM__INPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAlgorithmAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAlgorithmAccess().getPathSTRINGTerminalRuleCall_5_0(), semanticObject.getPath());
		feeder.accept(grammarAccess.getAlgorithmAccess().getOutputOutputParserRuleCall_7_0(), semanticObject.getOutput());
		feeder.accept(grammarAccess.getAlgorithmAccess().getInputInputParserRuleCall_9_0(), semanticObject.getInput());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Catalogue returns Catalogue
	 *
	 * Constraint:
	 *     (name=ID algorithms+=Algorithm*)
	 * </pre>
	 */
	protected void sequence_Catalogue(ISerializationContext context, Catalogue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Column returns Column
	 *
	 * Constraint:
	 *     (name=ID id=INT dataType=ColumnDataType constraint=Constraint)
	 * </pre>
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.COLUMN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.COLUMN__NAME));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.COLUMN__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.COLUMN__ID));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.COLUMN__DATA_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.COLUMN__DATA_TYPE));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.COLUMN__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.COLUMN__CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getColumnAccess().getIdINTTerminalRuleCall_5_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getColumnAccess().getDataTypeColumnDataTypeEnumRuleCall_7_0(), semanticObject.getDataType());
		feeder.accept(grammarAccess.getColumnAccess().getConstraintConstraintParserRuleCall_9_0(), semanticObject.getConstraint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constant returns Constant
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantAccess().getValueINTTerminalRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     filePath=STRING
	 * </pre>
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.CONSTRAINT__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.CONSTRAINT__FILE_PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintAccess().getFilePathSTRINGTerminalRuleCall_3_0(), semanticObject.getFilePath());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DerivedColumn returns DerivedColumn
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         id=INT 
	 *         dataType=ColumnDataType 
	 *         constraint=Constraint 
	 *         algorithm=Algorithm 
	 *         outputColumn=Output
	 *     )
	 * </pre>
	 */
	protected void sequence_DerivedColumn(ISerializationContext context, DerivedColumn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.DERIVED_COLUMN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.DERIVED_COLUMN__NAME));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.DERIVED_COLUMN__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.DERIVED_COLUMN__ID));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.DERIVED_COLUMN__DATA_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.DERIVED_COLUMN__DATA_TYPE));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.DERIVED_COLUMN__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.DERIVED_COLUMN__CONSTRAINT));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.DERIVED_COLUMN__ALGORITHM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.DERIVED_COLUMN__ALGORITHM));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.DERIVED_COLUMN__OUTPUT_COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.DERIVED_COLUMN__OUTPUT_COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDerivedColumnAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDerivedColumnAccess().getIdINTTerminalRuleCall_5_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getDerivedColumnAccess().getDataTypeColumnDataTypeEnumRuleCall_7_0(), semanticObject.getDataType());
		feeder.accept(grammarAccess.getDerivedColumnAccess().getConstraintConstraintParserRuleCall_9_0(), semanticObject.getConstraint());
		feeder.accept(grammarAccess.getDerivedColumnAccess().getAlgorithmAlgorithmParserRuleCall_11_0(), semanticObject.getAlgorithm());
		feeder.accept(grammarAccess.getDerivedColumnAccess().getOutputColumnOutputParserRuleCall_13_0(), semanticObject.getOutputColumn());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Input returns Input
	 *
	 * Constraint:
	 *     (constante=Constant columns+=[Column|ID]*)
	 * </pre>
	 */
	protected void sequence_Input(ISerializationContext context, Input semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Output returns Output
	 *
	 * Constraint:
	 *     (name=ID id=INT dataType=ColumnDataType constraint=Constraint)
	 * </pre>
	 */
	protected void sequence_Output(ISerializationContext context, Output semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.OUTPUT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.OUTPUT__NAME));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.OUTPUT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.OUTPUT__ID));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.OUTPUT__DATA_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.OUTPUT__DATA_TYPE));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.OUTPUT__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.OUTPUT__CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutputAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOutputAccess().getIdINTTerminalRuleCall_5_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getOutputAccess().getDataTypeColumnDataTypeEnumRuleCall_7_0(), semanticObject.getDataType());
		feeder.accept(grammarAccess.getOutputAccess().getConstraintConstraintParserRuleCall_9_0(), semanticObject.getConstraint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReferencedColumn returns ReferencedColumn
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         id=INT 
	 *         dataType=ColumnDataType 
	 *         constraint=Constraint 
	 *         foreignTable=[ShemaTable|ID] 
	 *         foreignColumn=[Column|ID]
	 *     )
	 * </pre>
	 */
	protected void sequence_ReferencedColumn(ISerializationContext context, ReferencedColumn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.REFERENCED_COLUMN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.REFERENCED_COLUMN__NAME));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.REFERENCED_COLUMN__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.REFERENCED_COLUMN__ID));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.REFERENCED_COLUMN__DATA_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.REFERENCED_COLUMN__DATA_TYPE));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.REFERENCED_COLUMN__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.REFERENCED_COLUMN__CONSTRAINT));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.REFERENCED_COLUMN__FOREIGN_TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.REFERENCED_COLUMN__FOREIGN_TABLE));
			if (transientValues.isValueTransient(semanticObject, XtextPackage.Literals.REFERENCED_COLUMN__FOREIGN_COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextPackage.Literals.REFERENCED_COLUMN__FOREIGN_COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferencedColumnAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getReferencedColumnAccess().getIdINTTerminalRuleCall_5_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getReferencedColumnAccess().getDataTypeColumnDataTypeEnumRuleCall_7_0(), semanticObject.getDataType());
		feeder.accept(grammarAccess.getReferencedColumnAccess().getConstraintConstraintParserRuleCall_9_0(), semanticObject.getConstraint());
		feeder.accept(grammarAccess.getReferencedColumnAccess().getForeignTableShemaTableIDTerminalRuleCall_11_0_1(), semanticObject.eGet(XtextPackage.Literals.REFERENCED_COLUMN__FOREIGN_TABLE, false));
		feeder.accept(grammarAccess.getReferencedColumnAccess().getForeignColumnColumnIDTerminalRuleCall_13_0_1(), semanticObject.eGet(XtextPackage.Literals.REFERENCED_COLUMN__FOREIGN_COLUMN, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ShemaTable returns ShemaTable
	 *
	 * Constraint:
	 *     (name=ID id=INT columns+=Column* catalogue=Catalogue)
	 * </pre>
	 */
	protected void sequence_ShemaTable(ISerializationContext context, ShemaTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Tables returns Tables
	 *
	 * Constraint:
	 *     shematables+=ShemaTable+
	 * </pre>
	 */
	protected void sequence_Tables(ISerializationContext context, Tables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
